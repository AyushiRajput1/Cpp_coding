Intuition
We can solve this problem using DFS + Binary Search Tree. (Recursive Approach).

Approach
We can easily understand the approach by seeing the code which is easy to understand with comments.

Complexity
Time complexity:
Time Complexity: O(N), where N is the total number of nodes in the given tree. We visit each node at most once.

Space complexity:
Space Complexity: O(N), Even though we don't explicitly use any additional memory, the call stack of our recursion could be as large as the number of nodes in the worst case.

Code
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */


/*

    Time Complexity: O(N), where N is the total number of nodes in the given tree. We visit each node
    at most once.

    Space Complexity: O(N), Even though we don't explicitly use any additional memory, the call stack
    of our recursion could be as large as the number of nodes in the worst case.

    Solved using DFS + Binary Search Tree. (Recursive Approach)

*/

class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if(root == NULL){
            return NULL;
        }
        if(root->val < low){
            return trimBST(root->right, low, high);
        }
        if(root->val > high){
            return trimBST(root->left, low, high);
        }
        root->left = trimBST(root->left, low, high);
        root->right = trimBST(root->right, low, high);   
        return root;
    }
};