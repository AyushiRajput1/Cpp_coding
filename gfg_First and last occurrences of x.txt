Time Complexity: O(N)
Auxiliary Space: O(1).

vector<int> find(int arr[], int n , int x )
{
    int mn=INT_MAX,mx=INT_MIN,f=0;
    vector<int> v;
    for(int i=0;i<n;i++)
    {
        if(arr[i]==x)
        {
            mn=min(i,mn);
            mx=max(i,mx);
            f=1;
        }
        if(arr[i]> x)
        {
            break;
        }
    }
    
    if(f==1)
        return {mn,mx};
    else
        return {-1,-1}; 
    
    return v;
}
------------------------------------------
Time Complexity: O(logN)
Auxiliary Space: O(1).


vector<int> find(int arr[], int n , int x )
{
    // code here
    
    int firstocc = lower_bound(arr, arr+n, x) - arr;
    int lastocc = upper_bound(arr, arr+n, x) - arr - 1;
    
    if(firstocc == n|| arr[firstocc] != x)
        return {-1, -1};
    
    return {firstocc, lastocc};
}

--------------------------------------------

vector<int> find(int arr[], int n , int x )
{
vector<int> k;
int s=0;
int e=n-1;
int ans1=-1;
int ans2=-1;
while(s<=e)
{
    int mid=s+(e-s)/2;
    if(arr[mid]==x)
    {
        ans1=mid;
        e=mid-1;
    }
    else if(arr[mid]<x)
    {
        s=mid+1;
        
    }
    else
    {
        e=mid-1;
   }
}
s=0;
e=n-1;
while(s<=e)
{
   int mid=s+(e-s)/2;
    if(arr[mid]==x)
    {
        ans2=mid;
        s=mid+1;
    }
    else if(arr[mid]<x)
    {
        s=mid+1;
        
    }
    else
    {
        e=mid-1;
    }  
}
k.push_back(ans1);
k.push_back(ans2);
return k;
    
}

---------------------------------------------------------------------------
Time Complexity: O(logN)
Auxiliary Space: O(1).

Algorithm:

1. Using Binary Search, find the index where the given element is present in the array.

2. If the element is not found in the array i.e. start > end then insert -1 twice in the ans vector. Return ans.

3. If element is found out then :

(i) using a variable i starting from mid index ( i = mid), traverse in backward direction of array while (arr[i] == x). When this loop ends, it indicates that arr[i] != x so push index i+1 as this was the first index in array where element is equal to x.

(ii) using a variable j starting from mid index ( j = mid), traverse in forward direction of array while (arr[j] == x). When this loop ends, it indicates that arr[j] != x so push index j-1 as this was last index in array where element is equal to x.

4. Return ans.

Code:

vector<int> find(int arr[], int n , int x )
{
    // code here
   
    long long start = 0, end = n-1;
    long long mid = start + (end - start)/2;
    while(start <= end)
    {
        if(arr[mid] == x)
        {
            break;
        }
        else if(arr[mid] < x)
        {
            start = mid+1;
        }
        else
        {
            end = mid-1;
        }
        mid = start + (end - start)/2;
    }
    vector<int> ans;
    if(start > end)
    {
        ans.push_back(-1);
        ans.push_back(-1);
        return ans;
    }
    long long i = mid;
    while(arr[i] == x)
    {
        i--;
    }
    ans.push_back(i+1);
    
    long long j = mid;
    while(arr[j] == x)
    {
        j++;
    }
    ans.push_back(j-1);
    
    return ans;
}

----------------------------------------------------------------------------
vector<int> find(int arr[], int n,int x)
{
    int start = -1;
    int end = -1;
    for(int i = 0;i<n;i++)
    {
        if(start == -1 and arr[i] == x)
        start = i;
        if(end == -1 and arr[n-i-1] == x)
        end = n-i-1;
    }
    return {start,end};
}

-------------------------------------------------------------------------------
int a = lower_bound(arr,arr+n,x)-arr,b = upper_bound(arr,arr+n,x)-arr-1;
if(arr[a] != x) return {-1,-1};
return {a,b};
int l = 0,h = n-1;
vector <int> v(2,-1);
if(!n) return v;
while(l < h){
    int m = (l+h)/2;
    if(arr[m] < x) l = m+1;
    else h = m; 
}
if(arr[l] != x) return v;
v[0] = l;
h = n-1;
while(l < h){
    int m = (l+h+1)/2;
    if(arr[m] > x) h = m-1;
    else l = m; 
}
v[1] = h;
return v;