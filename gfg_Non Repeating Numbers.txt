Method 2(Use XOR) 
Let x and y be the non-repeating elements we are looking for and arr[] be the input array. 
First, calculate the XOR of all the array elements. 

     xor = arr[0]^arr[1]^arr[2].....arr[n-1]
All the bits that are set in xor will be set in one non-repeating element (x or y) and not in others. 
So if we take any set bit of xor and divide the elements of the array in two sets – one set of elements with same bit set and another set with same bit not set. 
By doing so, we will get x in one set and y in another set. Now if we do XOR of all the elements in the first set, we will get the first non-repeating element,
 and by doing same in other sets we will get the second non-repeating element. 

Let us see an example.
   arr[] = {2, 4, 7, 9, 2, 4}
1) Get the XOR of all the elements.
     xor = 2^4^7^9^2^4 = 14 (1110)
2) Get a number which has only one set bit of the xor.   
   Since we can easily get the rightmost set bit, let us use it.
     set_bit_no = xor & ~(xor-1) = (1110) & ~(1101) = 0010
   Now set_bit_no will have only set as rightmost set bit of xor.
3) Now divide the elements in two sets and do xor of         
   elements in each set and we get the non-repeating 
   elements 7 and 9. Please see the implementation for this step.
Approach : 
Step 1: Xor all the elements of the array into a variable sum thus all the elements present twice in an array will get removed as for example, 4 = “100”
 and if 4 xor 4 => “100” xor “100” thus answer will be “000”. 
Step 2: Thus in the sum the final answer will be 3 xor 5 as both 2 and 4 are xor with itself giving 0, therefore sum = “011” xor “101” i.e sum = “110” = 6. 
Step 3: Now we will take 2’s Complement of sum i.e (-sum) = “010”. 
Step 4: Now bitwise And the 2’s of sum with the sum i.e “110” & “010” gives the answer “010” (Aim for bitwise & is that we want to get a number that contains
 only the rightmost set bit of the sum). 
Step 5: bitwise & all the elements of the array with this obtained sum, 2 = “010” & “010” = 2, 3 = “011” & “010” = “010” , 4 = “100” & “010” = “000”,
 5 = “101” & “010” = “000”. 
Step 6: As we can see that the bitwise & of 2,3 > 0 thus they will be xor with sum1 and bitwise & of 4,5 is resulting into 0 thus they will be xor with sum2. 
Step 7: As 2 is present two times so getting xor with sum1 two times only the result 3 is being stored in it and As 4 is also present two times thus getting 
xor with sum2 will cancel it’s value and thus only 5 will remain there.

Implementation: 


class Solution {
public:
    vector<int> singleNumber(vector<int> arr) 
    {
        int Xor = arr[0];
        int set_bit_no;
        int i;
        int x = 0;
        int y = 0;
 
    /* Get the Xor of all elements */
    for (i = 1; i < arr.size(); i++)
        Xor ^= arr[i];
 
    /* Get the rightmost set bit in set_bit_no */
    set_bit_no = Xor & ~(Xor - 1);
 
    /* Now divide elements in two sets by
    comparing rightmost set bit of Xor with bit
    at same position in each element. */
    for (i = 0; i <arr.size(); i++) 
    {
 
        /*Xor of first set */
        if (arr[i] & set_bit_no)
            x = x ^ arr[i];
        /*Xor of second set*/
        else {
            y = y ^ arr[i];
        }
        
    }    	
    
        vector<int> r ;
        r.push_back(x);
        r.push_back(y);
        
        if(r[0] > r[1])
        	swap(r[0], r[1]);
        	
        return r;
    }
};


Time Complexity: O(n) 
Auxiliary Space: O(1)
-----------------------------------------------------------


class Solution {
public:
    vector<int> singleNumber(vector<int> nums) 
    {
        // Pass 1 : 
        // Get the XOR of the two numbers we need to find
        long long int diff = 0;
        for(auto i: nums)
        	diff = i ^ diff;

        // Get its last set bit
        diff &= -diff;

        // Pass 2 :
        vector<int> rets = {0, 0}; // this vector stores the two numbers we will return
        for (int num : nums)
        {
            if ((num & diff) == 0) // the bit is not set
            {
                rets[0] ^= num;
            }
            else // the bit is set
            {
                rets[1] ^= num;
            }
        }
        if(rets[0] > rets[1])
        	swap(rets[0], rets[1]);
        return rets;
    }
};

--------------------------------------------------------------------------
class Solution
{
public:
    vector<int> singleNumber(vector<int> nums) 
    {
        map<int,int> m;
        vector<int> v;
        
        for(int i=0;i<nums.size();i++)
        {
            m[nums[i]]++;
        }
        
        for(auto i:m)
        {
            if(i.second==1)
            {
                v.push_back(i.first);
            }
            sort(v.begin(),v.end());
        }
        return v;
        
    }
};

Time Complexity: O(n log n) 
Auxiliary Space: O(n)
--------------------------------------------------------------------------
Method 4(Use Sets):
In this method, We check if the element already exists, if it exists we remove it else we add it to the set.

Approach:

Step 1: Take each element and check if it exists in the set or not. If it exists go to step 3. If it doesn’t exist go to step 2.
Step 2: Add the element to the set and go to step 4.
Step 3: Remove the element from the set and go to step 4.
Step 4: Print the elements of the set.

Implementation:


// C++ program to find 2 non repeating elements
// in array that has pairs of numbers
#include <bits/stdc++.h>
using namespace std;
 
// Method to print the 2 non repeating elements in an array
void print2SingleNumbers(int nums[], int n)
{
 
    // Create a Map Set to store the numbers
    multiset<int> set;
 
    /*Iterate through the array and check if each
    element is present or not in the set. If the
  element is present, remove it from the array
  otherwise add it to the set*/
 
    for (int i = 0; i < n; i++) {
        auto it = set.find(nums[i]);
        if (it != set.end())
            set.erase(it);
        else
            set.insert(nums[i]);
    }
 
    /*Since there will only be 2 non-repeating elements
  we can directly print them*/
    cout << "The 2 non repeating numbers are : "
         << *set.begin() << " " << *next(set.begin(), 1);
}
 
// Driver code
int main()
{
    int nums[] = { 2, 3, 7, 9, 11, 2, 3, 11 };
    int n = sizeof(nums) / sizeof(nums[0]);
    print2SingleNumbers(nums, n);
}
 
// This code is contributed by  phasing17
Output
The 2 non repeating numbers are : 7 9
Time Complexity: O(n) for a given array of size n
Auxiliary Space: O(n)